<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Multi Variable Regression - Machine Learning with TensorFlow</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="An introductory look at implementing machine learning algorithms using TensorFlow in Python.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="/public/book_deps/favicon.png">
        <link rel="stylesheet" href="/public/book_deps/css/variables.css">
        <link rel="stylesheet" href="/public/book_deps/css/general.css">
        <link rel="stylesheet" href="/public/book_deps/css/chrome.css">
        <link rel="stylesheet" href="/public/book_deps/css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="/public/book_deps/FontAwesome/css/font-awesome.css">
        <link href="/public/book_deps/fonts/SourceCodePro/source-code-pro.css" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="/public/book_deps/css/highlight.css">
        <link rel="stylesheet" href="/public/book_deps/css/tomorrow-night.css">
        <link rel="stylesheet" href="/public/book_deps/css/ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_book_root = "../";
            var path_to_site_root = "/public/book_deps/";
            var default_theme = "light";
            window.is_book_mode = true;
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="../ch1-setup/intro.html"><strong aria-hidden="true">1.</strong> Introduction and Setup</a></li><li><ol class="section"><li><a href="../ch1-setup/mac.html"><strong aria-hidden="true">1.1.</strong> macOS Setup</a></li><li><a href="../ch1-setup/linux.html"><strong aria-hidden="true">1.2.</strong> Linux Setup</a></li><li><a href="../ch1-setup/windows.html"><strong aria-hidden="true">1.3.</strong> Windows Setup</a></li></ol></li><li><a href="../ch2-linreg/intro.html"><strong aria-hidden="true">2.</strong> Linear Regression</a></li><li><ol class="section"><li><a href="../ch2-linreg/2017-12-03-single-variable.html"><strong aria-hidden="true">2.1.</strong> Single Variable Regression</a></li><li><a href="../ch2-linreg/2017-12-27-optimization.html"><strong aria-hidden="true">2.2.</strong> Optimization Convergence</a></li><li><a href="../ch2-linreg/2018-03-21-multi-variable.html" class="active"><strong aria-hidden="true">2.3.</strong> Multi Variable Regression</a></li><li><a href="../ch2-linreg/2018-11-15-feature-scaling.html"><strong aria-hidden="true">2.4.</strong> Feature Scaling</a></li><li><a href="../ch2-linreg/nonlinear.html"><strong aria-hidden="true">2.5.</strong> Nonlinear Regression</a></li><li><a href="../ch2-linreg/regularization.html"><strong aria-hidden="true">2.6.</strong> Regularization</a></li><li><a href="../ch2-linreg/evaluation.html"><strong aria-hidden="true">2.7.</strong> Evaluation</a></li><li><a href="../ch2-linreg/mle.html"><strong aria-hidden="true">2.8.</strong> Bonus: Why we square errors</a></li><li class="spacer"></li></ol></li></ol>
                <ol class="chapter">
                    <li><a href="/"><i class="fa fa-arrow-circle-left"></i> Home</a></li>
                </ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Machine Learning with TensorFlow</h1>

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#multi-variable-regression" id="multi-variable-regression"><h1>Multi Variable Regression</h1></a>
<p>In <a href="/books/tensorflow/book/ch2-linreg/2017-12-03-single-variable.html">chapter 2.1</a> we learned the basics of TensorFlow by creating a single variable linear regression model. In this chapter we expand this model to handle multiple variables. Note that less time will be spent explaining the basics of TensorFlow: only new concepts will be explained, so feel free to refer to previous chapters as needed.</p>
<a class="header" href="#motivation" id="motivation"><h2>Motivation</h2></a>
<p>Recall that a single variable linear regression model can learn to predict an output variable \(y\) under these conditions:</p>
<ol>
<li>There is only one input variable, \(x\)</li>
<li>There is a linear relationship between \(y\) and \(x\), that is, \(y \approx ax + b\)</li>
</ol>
<p>In practice, the above conditions are very limiting: if you have a simple data set then by all means you should try using single variable linear regression, but in most cases we have significantly more complex data. For example, consider using the following (abbreviated) <a href="https://www.kaggle.com/camnugent/california-housing-prices">data from the 1990 census</a> to learn to predict housing prices. Note that each row represents a single housing district:</p>
<table><thead><tr><th> House Median Age     </th><th> Total Rooms </th><th> Total Bedrooms </th><th> ... </th><th> Median House Value </th></tr></thead><tbody>
<tr><td> 41.0 </td><td> 880.0  </td><td> 129.0  </td><td> ...     </td><td> 452600.0    </td></tr>
<tr><td> 21.0 </td><td> 7099.0 </td><td> 1106.0 </td><td> ...     </td><td> 358500.0    </td></tr>
<tr><td> 52.0 </td><td> 1467.0 </td><td> 190.0  </td><td> ...     </td><td> 352100.0    </td></tr>
<tr><td> 52.0 </td><td> 1274.0 </td><td> 235.0  </td><td> ...     </td><td> 341300.0    </td></tr>
<tr><td> 52.0 </td><td> 1627.0 </td><td> 280.0  </td><td> ...     </td><td> 342200.0    </td></tr>
<tr><td> 52.0 </td><td> 919.0  </td><td> 213.0  </td><td> ...     </td><td> 269700.0    </td></tr>
<tr><td> ...  </td><td> ...    </td><td> ...    </td><td> ...     </td><td> ...         </td></tr>
</tbody></table>
<p>To predict the values of houses, we have at least 3 real-valued variables (age, number of rooms, number of dedrooms) that could potentially be useful. To analyze this sort of complex, real-world data we need to learn to handle multiple input variables.</p>
<p>One approach to handling multiple variables would be to reduce the number of input variables to only 1 variable, and then training a single variable linear regression model using that. In fact, an important area of research in machine learning (and one that will be covered later) called <strong><a href="https://en.wikipedia.org/wiki/dimensionality_reduction">dimensionality reduction</a></strong> deals with this problem of reducing the number of variables. However, it's important to realize that the number of variables can only be reduced so far, and its extremely rare that you can reduce a data set to only 1 variable. For now you need to take this statement on faith, but in later chapters we will investigate it more thoroughly.</p>
<p>So, it seems that we will have to deal with training models that can handle multiple variables. In this chapter we learn how to allow multiple input variables in our linear regression model. Such a model is called multi variable linear regression, or just linear regression.</p>
<a class="header" href="#theory" id="theory"><h2>Theory</h2></a>
<p>Most of the theory is similar to the theory for single variable linear regression, but we will need to augment and generalize it to handle multiple variables.</p>
<a class="header" href="#data-set-format" id="data-set-format"><h3>Data set format</h3></a>
<p>Previously we defined our data set \(D\) as consisting of many example pairs of \(x\) and \(y\), where \(m\) is the number of examples:
\[
D = \{ (x^{(1)}, y^{(1)}), (x^{(2)}, y^{(2)}), \cdots, (x^{(m)}, y^{(m))} \}
\]</p>
<p>Note that I have changed the notation compared to before. The notation \(x^{(i)}\) refers to the \(i\)'th \(x\) training example, it does <em>NOT</em> mean \(x\) to the \(i\)'th power, which would be written as \(x^i\). I promise the notation change will be useful shortly.</p>
<p>Alternatively, we can write \(D\) as 2 vectors of shape 1 x \(m\):
\[
D_x = \begin{bmatrix}
x^{(1)},
x^{(2)},
\dots,
x^{(m)}
\end{bmatrix} \\
D_y = \begin{bmatrix}
y^{(1)},
y^{(2)},
\dots,
y^{(m)}
\end{bmatrix}
\]</p>
<p>But now, we need each \(x^{(i)}\) example to contain multiple numbers, one for each input variable.  Let \(n\) be the number of input variables. Then the easiest way to write this is to let each \(x^{(i)}\) be a vector of shape \(n\) x 1. That is,
\[
x^{(i)} = \begin{bmatrix}
x^{(i)}_1 \\
x^{(i)}_2 \\
\vdots \\
x^{(i)}_j \\
\vdots \\
x^{(i)}_n
\end{bmatrix}
\]
Note that the notation \(x^{(i)}_j\) denotes the \(j\)'th input variable in the \(i\)'th example data.</p>
<p>Since each \(x^{(i)}\) has \(n\) rows, and \(D_x\) has \(m\) columns, each of which is an \(x^{(i)}\), we can write \(D_x\) as a massive \(n \times m\) matrix:
\[
D_x = \begin{bmatrix}
x^{(1)},
x^{(2)},
\dots,
x^{(m)} \end{bmatrix}
= \begin{bmatrix}
x^{(1)}_1 &amp; x^{(2)}_1  &amp; \dots &amp; x^{(i)}_1 &amp; \dots &amp; x^{(m)}_1 \\
x^{(1)}_2 &amp; x^{(2)}_2  &amp; \dots &amp; x^{(i)}_2 &amp; \dots &amp; x^{(m)}_2 \\
\vdots &amp; \vdots  &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots \\
x^{(1)}_j &amp; x^{(2)}_j  &amp; \dots &amp; x^{(i)}_j &amp; \dots &amp; x^{(m)}_j \\
\vdots &amp; \vdots  &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots \\
x^{(1)}_n &amp; x^{(2)}_n  &amp; \dots &amp; x^{(i)}_n &amp; \dots &amp; x^{(m)}_n \\
\end{bmatrix}
\]
So, each column of \(D_x\) represents a single input data example. We don't need to change the 1 x \(m\) vector \(D_y\), since we still only have 1 output variable.</p>
<a class="header" href="#model-concept" id="model-concept"><h3>Model concept</h3></a>
<p>So, we now have an input data matrix \(D_x\) with each column vector representing a single input data example, and we have the corresponding \(D_y\) row vector, each entry of which is an output data example. How do we define a model which can linearly estimate the output \(y'^{(i)}\) given the input data vector \(x^{(i)}\)? Let's build it up from simple concepts, and build towards more complex linear algebra.</p>
<p>Since we want \(y'^{(i)}\) to depend linearly on each \(x^{(i)}_j\) for \(1 \leq j \leq n\), we can write:
\[
y'^{(i)} = a_1 x^{(i)}_1 + a_2 x^{(i)}_2 + \cdots + a_j x^{(i)}_j + \cdots + a_n x^{(i)}_n + b
\]</p>
<p>This is fine mathematically, but it's not very general. Suppose \(n = 100\): then we would have to literally write out 100 terms in our TensorFlow code. We can generalize this using linear algebra. Let \(A\) be a row vector of shape 1 x \(n\), containing each \(a_j\):
\[
A = \begin{bmatrix}
a_1,
a_2,
\cdots,
a_j,
\cdots,
a_n
\end{bmatrix}
\]</p>
<p>Now, let's see what happens if we compute \(A x^{(i)}\), as matrix multiplication. Note that \(A\) has shape 1 x \(n\) and \(x^{(i)}\) has shape \(n\) x 1. This is perfect! When performing matrix multiplication, the inner dimensions (in this case \(n\) and \(n\)) have to match, and the outer dimensions (in this case \(1\) and \(1\)) determine the output shape of the multiplication. So \(A x^{(i)}\) will have shape 1 x 1, or in other words, just a single number, in fact it is exactly \(y'^{(i)}\). How does this matrix multiplication exactly work? I'll refer you to <a href="https://www.khanacademy.org/math/precalculus/precalc-matrices/multiplying-matrices-by-matrices/v/matrix-multiplication-intro">this video by Khan Academy</a>, and explain it briefly in this case. Here, it is easier since \(A\) is a row vector, and \(x^{(i)}\) is a column vector. We simply multiply each corresponding entry, and add it all up:
\[
A x^{(i)} + b
= \begin{bmatrix}
a_1,
a_2,
\cdots,
a_j,
\cdots,
a_n
\end{bmatrix} \begin{bmatrix}
x^{(i)}_1 \\
x^{(i)}_2 \\
\vdots \\
x^{(i)}_j \\
\vdots \\
x^{(i)}_n
\end{bmatrix} + b
= a_1 x^{(i)}_1 + a_2 x^{(i)}_2 + \cdots + a_j x^{(i)}_j + \cdots + a_n x^{(i)}_n + b
= y'^{(i)}
\]</p>
<p>This matrix equation, \(y'(x, A, b) = Ax + b\) is exactly what we want as our model. As one final note, recall that in the actual implementation, we don't want \(x\) and \(y'\) to represent just one input data and predicted output, we want them to represent several. Since \(x\) is a column vector, the natural way to represent multiple input data points is with a matrix, very similar to the matrix \(D_x\), just not necessarily with <em>all</em> the columns of \(D_x\), and \(y'\) should be a row vector. Specifically, \(A\) has shape 1 x \(n\), \(x\) has shape \(n\) x <code>None</code>, and \(y\) has shape 1 x <code>None</code>, using the TensorFlow convention that <code>None</code> represents a yet-to-be-determined matrix size.</p>
<p>Now defining the loss function is pretty much the same as before, just using the new model:
\[
L(A, b) = \sum_{i=1}^m (y'(x^{(i)}, A, b) - y^{(i)})^2 = \sum_{i=1}^m (A x^{(i)} + b - y^{(i)})^2
\]</p>
<p>To minimize the loss function, we use the same process as before, gradient descent. However, previously the gradient descent was altering 2 variables (\(a\) and \(b\)) so as to minimize the loss function, and so we could plot the loss function and gradient descent progress in terms of \(a\) and \(b\). However, now the optimization needs to alter many more variables, since \(A\) actually contains \(n\) variables, the gradient descent must be performed in \(n+1\) dimensional space, and we don't have an easy way to visualize this.</p>
<p>With the more general linear algebra formulation of linear regression under our belts, let's move on to actually coding stuff.</p>
<a class="header" href="#implementation" id="implementation"><h2>Implementation</h2></a>
<p>As before, we need to: import data, define the model, define the loss function, run gradient descent, and finally make predictions. Many steps will be similar to the single variable case, but for completeness I will walk through them briefly.</p>
<p>For building and testing the implementation we will use a synthetic data set consisting of \(n=2\) input variables. You can download <a href="/books/tensorflow/book/ch2-linreg/code/linreg-multi-synthetic-2.csv">the synthetic data set here</a>. By synthetic, I mean that I purposefully created a very nicely behaved data set so that we can practice implementing multi variable linear regression, and verify that we converged to the right answer. In fact, the synthetic data is generated as \(y = 2x_1 + 1.3x_2 + 4 + \varepsilon \) where \(\varepsilon\) is random noise. If we implement multi variable linear regression correctly, then we should obtain approximately \(A = \begin{bmatrix} 2, 1.3 \end{bmatrix}, b = 4\). This plot illustrates what the data looks like in 3 dimensions, essentially a plane in 3 dimensions with some random fluctuations:</p>
<p><img src="/books/tensorflow/book/ch2-linreg/assets/linreg-multi-synthetic-2.png" alt="scatter" /></p>
<a class="header" href="#importing-the-data" id="importing-the-data"><h3>Importing the data</h3></a>
<p>As explained above, the input data set can be organized as an \(n \times m\) matrix. Since we will load the entire data set (input and output) from a single CSV file, and we have 2 input variables, the CSV file will contain 3 columns: the first 2 are the input variables, and the last one is the output variable. So, first we load the CSV file into an \(m\) x 3 matrix, and then separate the first 2 columns from the last:</p>
<pre><code class="language-python">import numpy as np
import tensorflow as tf
import pandas as pd
import matplotlib.pyplot as plt

# First we load the entire CSV file into an m x 3
D = np.matrix(pd.read_csv(&quot;linreg-multi-synthetic-2.csv&quot;, header=None).values)

# We extract all rows and the first 2 columns into X_data
# Then we flip it
X_data = D[:, 0:2].transpose()

# We extract all rows and the last column into y_data
# Then we flip it
y_data = D[:, 2].transpose()

# And make a convenient variable to remember the number of input columns
n = 2
</code></pre>
<p>The syntax <code>D[:, 0:2]</code> might be new, particularly if you haven't worked with NumPy before. In the single variable implementation we used Panda's functionality to access the columns by column name. This is a great approach, but sometimes you might need to be more flexible in how you access columns of data.</p>
<blockquote>
<p><strong>Note:</strong> The basic syntax for subscripting a matrix is: <code>D[3, 6]</code> (for example), which refers to the row at index 3 and the column at index 6 in the matrix <code>D</code>. Note that in <code>numpy</code> the row and column indices start at 0! This means that <code>D[0, 0]</code> refers to the top-left entry of matrix <code>D</code>. If you are coming from a pure math background, or have used MATLAB before, it is a common error to assume the indices start at 1. <br /><br />
Now for slicing, the <code>:</code> character is used to indicate a range. If it is used by itself, it indicates the entire range of rows / columns. For example, <code>D[:, 42]</code> refers to all rows of <code>D</code>, and the column at index 42. If it is used with indices, then <code>i:j</code> indicates the range of rows / columns at indices <code>i</code>, <code>i+1</code>, ..., <code>j-1</code>, but <em>not</em> including <code>j</code>. <br /><br />
So, <code>D[:, 0:2]</code> means to read the values in <code>D</code> at all rows and at columns with index <code>0</code> and <code>1</code> (the entire first 2 columns, i.e. the input data columns). Likewise, <code>D[:, 2]</code> means to read the values in <code>D</code> at all rows and at the column of index <code>2</code> (the entire last column, i.e. the output data column).</p>
</blockquote>
<p>This matrix subscripting and slicing is almost what we want, but not quite. The problem is that <code>D[:, 0:2]</code>, which contains our \(D_x\) data, is a matrix of shape \(m \times n\), but earlier we decided that we wanted \(D_x\) to be an \(n \times m\) matrix, so we need to flip it. To do so, we use the <a href="https://en.wikipedia.org/wiki/Transpose"><strong>transpose</strong></a> of the matrix. Mathematically we write the transpose of a matrix \(A\) as \(A^T\), and in Python we can compute it using <code>A.transpose()</code>. Essentially, the transpose of a matrix simply flips it along the diagonal, as shown in this animation:</p>
<p><center></p>
<p><a href="https://commons.wikimedia.org/wiki/File:Matrix_transpose.gif#/media/File:Matrix_transpose.gif"><img src="https://upload.wikimedia.org/wikipedia/commons/e/e4/Matrix_transpose.gif" alt="Matrix transpose.gif"></a><br>By <a href="//commons.wikimedia.org/wiki/User:LucasVB" title="User:LucasVB">LucasVB</a> - <a href="https://commons.wikimedia.org/w/index.php?curid=21897854">Link</a></p>
</center>
<p>So, <code>D[:, 0:2].transpose()</code> is a matrix of shape \(n \times m\), and is our correct data input matrix \(D_x\). We save this matrix to the variable <code>X_data</code>. Likewise, we also transpose <code>D[:, 2]</code> to correctly compute \(D_y\), and save it in <code>y_data</code>.</p>
<p>At this point we have our \(m \times n\) input data matrix <code>X_data</code> and our \(m \times 1\) output vector <code>y_data</code> loaded. In addition, we conveniently have the number of columns stored in <code>n</code>, so now we can start defining our model.</p>
<a class="header" href="#defining-the-model" id="defining-the-model"><h3>Defining the model</h3></a>
<p>As shown above, we want our model parameters to consist of a matrix \(A\) of size \(1 \times n\) and a single number \(b\). Then, we define:
\[
y'(x, A, b) = Ax + b
\]</p>
<p>First, we can define the input and correct output placeholders:</p>
<pre><code class="language-python"># Define data placeholders
x = tf.placeholder(tf.float32, shape=(n, None))
y = tf.placeholder(tf.float32, shape=(1, None))
</code></pre>
<p>And then we can define the trainable variables, the output prediction, and the loss function:</p>
<pre><code class="language-python"># Define trainable variables
A = tf.get_variable(&quot;A&quot;, shape=(1, n))
b = tf.get_variable(&quot;b&quot;, shape=())

# Define model output
y_predicted = tf.matmul(A, x) + b

# Define the loss function
L = tf.reduce_sum((y_predicted - y)**2)
</code></pre>
<a class="header" href="#training-the-model" id="training-the-model"><h3>Training the model</h3></a>
<p>At this point, we have a 1 dimensional output <code>y_predicted</code> which we compare against <code>y</code> using <code>L</code> to train the model, which is exactly the same situation as single variable linear regression. The remaining code to train the model is extremely similar, so I'll simply display it here, and then explain the few differences:</p>
<pre><code class="language-python"># Define optimizer object
optimizer = tf.train.AdamOptimizer(learning_rate=0.1).minimize(L)

# Create a session and initialize variables
session = tf.Session()
session.run(tf.global_variables_initializer())

# Main optimization loop
for t in range(2000):
    _, current_loss, current_A, current_b = session.run([optimizer, L, A, b], feed_dict={
        x: X_data,
        y: y_data
    })
    print(&quot;t = %g, loss = %g, A = %s, b = %g&quot; % (t, current_loss, str(current_A), current_b))
</code></pre>
<p>First, we have a different learning rate than the learning rate used in single variable regression. Even though the training algorithm is the same, since this is a different problem than single variable regression, we need find a good learning rate specific to this problem. A great way to do this for your own problems is using TensorBoard, as explained in the chapter <a href="https://donaldpinckney.com/books/tensorflow/book/ch2-linreg/2017-12-27-optimization.html">Optimization Convergence</a>.</p>
<p>Besides this, the only other conceptual difference is that at each step of the optimizer we are modifying the entire vector <code>A</code> (in addition to <code>b</code>), rather than just a single number. However, TensorFlow abstracts this away for us, and conceptually we just need to know that we are training the variable <code>A</code>.</p>
<p>The final print statements should output something close to:</p>
<pre><code>t = 1994, loss = 1.44798e+06, A = [[ 2.00547647  1.3020972 ]], b = 3.95038
t = 1995, loss = 1.44798e+06, A = [[ 2.00547647  1.3020972 ]], b = 3.95038
t = 1996, loss = 1.44798e+06, A = [[ 2.00547647  1.3020972 ]], b = 3.95038
t = 1997, loss = 1.44798e+06, A = [[ 2.00547647  1.3020972 ]], b = 3.95038
t = 1998, loss = 1.44798e+06, A = [[ 2.00547647  1.3020972 ]], b = 3.95038
t = 1999, loss = 1.44798e+06, A = [[ 2.00547647  1.3020972 ]], b = 3.95038
</code></pre>
<p>At this point we have converged to our approximate solution of \(A \approx \begin{bmatrix}
2.005,
1.302
\end{bmatrix}, b \approx 3.95\). Note that this is not exactly the same as the expected answer of \(A = \begin{bmatrix}
2,
1.3
\end{bmatrix}, b \approx 4\), primarily because some random noise was added to each point in the data set.</p>
<p>The model is fully trained, so now given a new input \(x\) we could now predict the output \(y' = Ax + b\), using all the learned information from all input variables.</p>
<a class="header" href="#concluding-remarks" id="concluding-remarks"><h1>Concluding Remarks</h1></a>
<p>Linear regression with multiple variables is only slightly different in essence from single variable linear regression. The main difference is abstracting the linear operation \(ax\) where \(a\) and \(x\) are single numbers to the linear operation \(Ax\), where now \(A\) is a matrix, \(x\) is a vector. In addition, at the implementation level we also have to deal with loading data in a more sophisticated manner, but otherwise the code is mostly the same. In later chapters we will use this abstraction we have built to define even more powerful models.</p>
<a class="header" href="#challenge-problems" id="challenge-problems"><h1>Challenge Problems</h1></a>
<p>So far this chapter has used a synthetic data set, <code>linreg-multi-synthetic-2.csv</code>, for easy demonstration. The exercises are primarily concerned with getting practice at applying this model to real-world data. Note that in real-world data not all columns are useful, and some might not have a linear relationship with the MPG. Including these unhelpful columns in your model might decrease the accuracy of your model. You should try plotting various columns vs. the output column to determine which seem most helpful in predicting the output, and then only include these useful columns as your input.</p>
<p>In addition, many data sets will have so called <em>messy data</em>, which require you to do some manipulation in Python to make sure the data is imported cleanly and properly. For example, some rows might containg missing data: for these your code can not crash or incorrectly import the data. Instead, you need to adopt a strategy to still import the data as best as you can: for example, you can simply ignore any rows that have incomplete data.</p>
<p>Note that we have not discussed how to rigorously evaluate how good a model is yet. For now you can use the value of the loss function, along with some intuition and creating plots. Evaluation will be discussed more in chapter 2.7.</p>
<ol>
<li>Download <a href="https://www.kaggle.com/uciml/red-wine-quality-cortez-et-al-2009">this red wine quality data set</a>, and try to predict the quality of the wine (last column) from the physicochemical input data (other columns).</li>
<li>Download <a href="https://archive.ics.uci.edu/ml/datasets/Auto+MPG">this car MPG data set</a>, and try to predict the MPG (first column) based on some of the other columns.</li>
<li>Download <a href="https://www.kaggle.com/camnugent/california-housing-prices">this California 1990 Housing Value data set</a>, and try to predict the house values based on various factors.</li>
</ol>
<a class="header" href="#complete-code" id="complete-code"><h1>Complete Code</h1></a>
<p>The <a href="https://github.com/donald-pinckney/donald-pinckney.github.io/blob/src/books/tensorflow/src/ch2-linreg/code/multi_var_reg.py">complete example code is available on GitHub</a>, as well as directly here:</p>
<pre><code class="language-python">import numpy as np
import tensorflow as tf
import pandas as pd
import matplotlib.pyplot as plt

# First we load the entire CSV file into an m x 3
D = np.matrix(pd.read_csv(&quot;linreg-multi-synthetic-2.csv&quot;, header=None).values)

# We extract all rows and the first 2 columns into X_data
# Then we flip it
X_data = D[:, 0:2].transpose()

# We extract all rows and the last column into y_data
# Then we flip it
y_data = D[:, 2].transpose()

# And make a convenient variable to remember the number of input columns
n = 2

# Define data placeholders
x = tf.placeholder(tf.float32, shape=(n, None))
y = tf.placeholder(tf.float32, shape=(1, None))

# Define trainable variables
A = tf.get_variable(&quot;A&quot;, shape=(1, n))
b = tf.get_variable(&quot;b&quot;, shape=())

# Define model output
y_predicted = tf.matmul(A, x) + b

# Define the loss function
L = tf.reduce_sum((y_predicted - y)**2)

# Define optimizer object
optimizer = tf.train.AdamOptimizer(learning_rate=0.1).minimize(L)

# Create a session and initialize variables
session = tf.Session()
session.run(tf.global_variables_initializer())

# Main optimization loop
for t in range(2000):
    _, current_loss, current_A, current_b = session.run([optimizer, L, A, b], feed_dict={
        x: X_data,
        y: y_data
    })
    print(&quot;t = %g, loss = %g, A = %s, b = %g&quot; % (t, current_loss, str(current_A), current_b))

</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../ch2-linreg/2017-12-27-optimization.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../ch2-linreg/2018-11-15-feature-scaling.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../ch2-linreg/2017-12-27-optimization.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../ch2-linreg/2018-11-15-feature-scaling.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="/public/book_deps/js/elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="/public/book_deps/js/mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="/public/book_deps/js/searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="/public/book_deps/js/clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="/public/book_deps/js/highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="/public/book_deps/js/book.js" type="text/javascript" charset="utf-8"></script>
        <script src="/public/js/code-snippets.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
