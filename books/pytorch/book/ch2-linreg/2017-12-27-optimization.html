<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Optimization Convergence - Machine Learning with PyTorch</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="An introductory look at implementing machine learning algorithms using Python and PyTorch.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="/public/book_deps/favicon.png">
        <link rel="stylesheet" href="/public/book_deps/css/variables.css">
        <link rel="stylesheet" href="/public/book_deps/css/general.css">
        <link rel="stylesheet" href="/public/book_deps/css/chrome.css">
        <link rel="stylesheet" href="/public/book_deps/css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="/public/book_deps/FontAwesome/css/font-awesome.css">
        <link href="/public/book_deps/fonts/SourceCodePro/source-code-pro.css" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="/public/book_deps/css/highlight.css">
        <link rel="stylesheet" href="/public/book_deps/css/tomorrow-night.css">
        <link rel="stylesheet" href="/public/book_deps/css/ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_book_root = "../";
            var path_to_site_root = "/public/book_deps/";
            var default_theme = "light";
            window.is_book_mode = true;
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="../ch1-setup/intro.html"><strong aria-hidden="true">1.</strong> Introduction and Setup</a></li><li><ol class="section"><li><a href="../ch1-setup/mac.html"><strong aria-hidden="true">1.1.</strong> macOS Setup</a></li><li><a href="../ch1-setup/linux.html"><strong aria-hidden="true">1.2.</strong> Linux Setup</a></li><li><a href="../ch1-setup/windows.html"><strong aria-hidden="true">1.3.</strong> Windows Setup</a></li></ol></li><li><a href="../ch2-linreg/intro.html"><strong aria-hidden="true">2.</strong> Linear Regression</a></li><li><ol class="section"><li><a href="../ch2-linreg/2017-12-03-single-variable.html"><strong aria-hidden="true">2.1.</strong> Single Variable Regression</a></li><li><a href="../ch2-linreg/2017-12-27-optimization.html" class="active"><strong aria-hidden="true">2.2.</strong> Optimization Convergence</a></li><li><a href="../ch2-linreg/2018-03-21-multi-variable.html"><strong aria-hidden="true">2.3.</strong> Multi Variable Regression</a></li><li><a href="../ch2-linreg/2018-11-15-feature-scaling.html"><strong aria-hidden="true">2.4.</strong> Feature Scaling</a></li><li><a href="../ch2-linreg/nonlinear.html"><strong aria-hidden="true">2.5.</strong> Nonlinear Regression</a></li><li><a href="../ch2-linreg/regularization.html"><strong aria-hidden="true">2.6.</strong> Regularization</a></li><li><a href="../ch2-linreg/evaluation.html"><strong aria-hidden="true">2.7.</strong> Evaluation</a></li><li><a href="../ch2-linreg/mle.html"><strong aria-hidden="true">2.8.</strong> Bonus: Why we square errors</a></li><li class="spacer"></li></ol></li></ol>
                <ol class="chapter">
                    <li><a href="/"><i class="fa fa-arrow-circle-left"></i> Home</a></li>
                </ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Machine Learning with PyTorch</h1>

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#exploring-optimization-convergence" id="exploring-optimization-convergence"><h1>Exploring Optimization Convergence</h1></a>
<p>In the previous chapter we created a simple single variable linear regression model to fit a data set. While the Python code was actually fairly short and simple, I did gloss over some details related to the optimization, and I hope to use this short chapter to answer some dangling questions about it. Since this chapter doesn't introduce new models or concepts you can skip it (or come back later) if you prefer. However, getting a feel for optimization is useful for training just about any model, not just the single variable linear regression model, and this chapter should give you insight that is useful for the rest of this guide and just about any machine learning you do.</p>
<p>To explore optimization we are going to exactly copy the code from the previous chapter, and experiment with it. To review, let's look at the part of the code from before that performed the optimization (just look at the previous chapter if you need to review the entire thing):</p>
<pre><code class="language-python"># Setup the optimizer object, so it optimizes a and b.
optimizer = optim.Adam([a, b], lr=0.2)

# Main optimization loop
for t in range(10000):
    # Set the gradients to 0.
    optimizer.zero_grad()
    # Compute the current predicted y's from x_dataset
    y_predicted = model(x_dataset)
    # See how far off the prediction is
    current_loss = loss(y_predicted, y_dataset)
    # Compute the gradient of the loss with respect to a and b.
    current_loss.backward()
    # Update a and b accordingly.
    optimizer.step()
    print(f&quot;t = {t}, loss = {current_loss}, a = {a.item()}, b = {b.item()}&quot;)
</code></pre>
<p>The main unanswered questions to address are:</p>
<ol>
<li>I said that the learning rate affects how large of steps the optimization algorithm takes in one unit of time. But how do we choose an appropriate value for the learning rate, such as <code>0.2</code>?</li>
<li>What is this <code>AdamOptimizer</code> exactly, are there other choices for optimizers, and how do they differ?</li>
<li>Currently this code runs for <code>10000</code> iterations, and that seems good enough to fully optimize <code>L</code>. But how do we choose this appropriate amount of time for training?</li>
</ol>
<p>There aren't exact or easy answers to the above questions, but answering these questions is made even harder by the fact that we can not effectively visualize the training progress with the code we have.  Currently we have some <code>print(...)</code> statements, which is good enough to see that the training error is decreasing, but not much more than that. Let's start with learning how to visualize training, since this will help us address the other questions and give us a deeper intuition about optimization.</p>
<a class="header" href="#how-to-visualize-training-progress" id="how-to-visualize-training-progress"><h2>How to visualize training progress</h2></a>
<a class="header" href="#extracting-hyperparameters" id="extracting-hyperparameters"><h3>Extracting hyperparameters</h3></a>
<p>One of the simplest ways to visualize training progress is to plot the value of the loss function over time. We could certainly plot the value of the loss function using matplotlib, like we plotted the data set. But PyTorch actually lets us plot training progress conveniently in real time by communicating with a tool called TensorBoard. It's pretty handy, but first we need to do some work to refactor our current code.</p>
<p>The first thing I'd like to do is move <strong>hyperparameters</strong> to the top of the script. What exactly are <strong>hyperparameters</strong>? They are parameters that affect how the training of the model proceeds, but are not part of the model itself. For example, \(a\) and \(b\) are parameters, while the learning rate \(\alpha\) is a hyperparameter. The hyperparameters we have are:</p>
<ol>
<li>The learning rate, currently <code>0.2</code>.</li>
<li>The number of training iterations, currently <code>10000</code>.</li>
<li>The choice of optimization routine, currently <code>tf.train.AdamOptimizer</code> (This isn't often thought of as a hyperparameter, but here we'll think of it as one).</li>
</ol>
<p>So, we can just put these into constants at the top of the code. Also, we are going to change these values to give us a simpler starting point:</p>
<pre><code class="language-python">import pandas as pd
import matplotlib.pyplot as plt
import torch
import torch.optim as optim

### Hyperparameters ###

LEARNING_RATE = 0.000001 # Much smaller training rate, to make sure the optimization is at least reliable.
NUM_ITERS = 20000 # Twice as many training iterations, just gives us more room to experiment later.
OPTIMIZER_CONSTRUCTOR = optim.SGD # This is the simplest optimization algorithm.

# .. all the rest of the code, hyperparameter constants properly substituted
</code></pre>
<a class="header" href="#installing-tensorboard" id="installing-tensorboard"><h3>Installing TensorBoard</h3></a>
<p>Next we need to actually install TensorBoard on our system. The following command should do it:</p>
<pre><code class="language-bash">pip3 install tb-nightly future
</code></pre>
<a class="header" href="#setting-up-tensorboard" id="setting-up-tensorboard"><h3>Setting up TensorBoard</h3></a>
<p>Now, we need to add some code to configure TensorBoard for our model. We will need to add a new import:</p>
<pre><code class="language-python">from torch.utils.tensorboard import SummaryWriter
</code></pre>
<p>We want to tell PyTorch where to save a log of all the parameter and loss values. We setup the log location based on the values of the hyperparameters:</p>
<pre><code class="language-python"># ... above this is where loss is defined

### TensorBoard Writer Setup ###

log_name = f&quot;{LEARNING_RATE}, {OPTIMIZER_CONSTRUCTOR.__name__}&quot;
writer = SummaryWriter(log_dir=f&quot;runs/{log_name}&quot;)
print(&quot;To see tensorboard, run: tensorboard --logdir=runs/&quot;)

# ... below this is where we create the optimizer and session
</code></pre>
<p>The point of basing the log location names on the hyperparameter values is so that we can later compare logs that used different hyperparameters.</p>
<p>The last thing we need to do is make PyTorch actually write the values of <code>a</code>, <code>b</code> and the loss to the log as training progresses. In our training code before we had a <code>print</code> statement that showed how training was going, but now we can replace it (or keep it, you choose):</p>
<pre><code class="language-python"># Main optimization loop
for t in range(NUM_ITERS):
    # Set the gradients to 0.
    optimizer.zero_grad()
    # Compute the current predicted y's from x_dataset
    y_predicted = model(x_dataset)
    # See how far off the prediction is
    current_loss = loss(y_predicted, y_dataset)
    # Compute the gradient of the loss with respect to a and b.
    current_loss.backward()
    # Update a and b accordingly.
    optimizer.step()

    # This is where we write the current values of a, b, and loss to the log.
    # global_step=t tells tensorboard at what step of the training this is.
    writer.add_scalar('a', a, global_step=t)
    writer.add_scalar('b', b, global_step=t)
    writer.add_scalar('L', current_loss, global_step=t)

# After we are done with the writer, we should close the log file.
writer.close()
</code></pre>
<p>And as a final touch, we can also delete or comment out the code that plots the data set, since it reduces the amount of clicking we have to do when trying different hyperparameters. The complete modified code should look something like this:</p>
<pre><code class="language-python">import pandas as pd
import matplotlib.pyplot as plt
import torch
import torch.optim as optim
from torch.utils.tensorboard import SummaryWriter

### Hyperparameters ###

LEARNING_RATE = 0.000001 # Much smaller training rate, to make sure the optimization is at least reliable.
NUM_ITERS = 20000 # Twice as many training iterations, just gives us more room to experiment later.
OPTIMIZER_CONSTRUCTOR = optim.SGD # This is the simplest optimization algorithm.

# Load the data
D = pd.read_csv(&quot;homicide.csv&quot;)
x_dataset = torch.tensor(D.age.values, dtype=torch.float)
y_dataset = torch.tensor(D.num_homicide_deaths.values, dtype=torch.float)


### Model definition ###

# First we define the trainable parameters a and b 
a = torch.randn(1, requires_grad=True) # requires_grad means it is trainable
b = torch.randn(1, requires_grad=True)

# Then we define the prediction model
def model(x_input):
    return a * x_input + b


### Loss function definition ###

def loss(y_predicted, y_target):
    return ((y_predicted - y_target)**2).sum()


### TensorBoard Writer Setup ###

log_name = f&quot;{LEARNING_RATE}, {OPTIMIZER_CONSTRUCTOR.__name__}&quot;
writer = SummaryWriter(log_dir=f&quot;runs/{log_name}&quot;)
print(&quot;To see tensorboard, run: tensorboard --logdir=runs/&quot;)


### Training the model ###

# Setup the optimizer object, so it optimizes a and b.
optimizer = OPTIMIZER_CONSTRUCTOR([a, b], lr=LEARNING_RATE)

# Main optimization loop
for t in range(NUM_ITERS):
    # Set the gradients to 0.
    optimizer.zero_grad()
    # Compute the current predicted y's from x_dataset
    y_predicted = model(x_dataset)
    # See how far off the prediction is
    current_loss = loss(y_predicted, y_dataset)
    # Compute the gradient of the loss with respect to a and b.
    current_loss.backward()
    # Update a and b accordingly.
    optimizer.step()

    writer.add_scalar('a', a, global_step=t)
    writer.add_scalar('b', b, global_step=t)
    writer.add_scalar('L', current_loss, global_step=t)

writer.close()
</code></pre>
<a class="header" href="#using-tensorboard" id="using-tensorboard"><h3>Using TensorBoard</h3></a>
<p>With the Python code prepared, we can now run it and use TensorBoard to visualize the training. First, run the Python code as usual, using Terminal, or your IDE. This will write logs to <code>runs/{log_name}</code> (relative to the directory from where you run the code). Now, we can open this up with TensorBoard, by running this command in Terminal:</p>
<pre><code class="language-bash">tensorboard --logdir=runs/
</code></pre>
<p>Once you run that command, go to <a href="http://localhost:6006">http://localhost:6006</a> in your web browser, and you should see plots of <code>L</code>, <code>a</code>, and <code>b</code> as the training progressed. With the hyperparameter choices from above, the plots should look like:</p>
<p><img src="/books/pytorch/book/ch2-linreg/assets/tensorboard_1.png" alt="TensorBoard 1" /></p>
<a class="header" href="#interpreting-the-tensorboard-plots" id="interpreting-the-tensorboard-plots"><h2>Interpreting the TensorBoard plots</h2></a>
<p>Ok, so now we have some plots showing the progression of <code>L</code>, <code>a</code>, and <code>b</code>. What can these plots tell us? Well, with the current choice of <code>LEARNING_RATE = 0.000001</code>, the plot for <code>L</code> clearly continues to decrease continually during training. This is good, since this means that the <code>optim.SGD</code> is doing it's job of decreasing the value of the loss function. However, the loss function continues to decrease quickly even towards the end of training: it is reasonable to expect that the loss function would continue to decrease substantially if we continued to train for more iterations. Therefore, we have not found the minimum of the loss function.</p>
<p>To remedy this, we could do one of 3 things: run the training for more iterations, increase the learning rate, or experiment with another optimization algorithm. We don't want to train for more iterations unless we have to, since that just takes more time, so we will start with increasing the learning rate.</p>
<a class="header" href="#increasing-the-learning-rate" id="increasing-the-learning-rate"><h2>Increasing the learning rate</h2></a>
<p>Currently the learning rate is <code>0.000001</code>, and is too small. A pretty easy way to try new learning rates is to go roughly by powers of 10. For now, we can try <code>0.000001</code>, <code>0.000005</code>, <code>0.00001</code>. For each of these, you can just tweak the <code>LEARNING_RATE</code> constant, and re-run the code. You don't need to re-run the TensorBoard command (but you can), but make sure to reload the <a href="http://localhost:6006">http://localhost:6006</a> page once you do all the runs. You should get plots that look like:</p>
<p><img src="/books/pytorch/book/ch2-linreg/assets/tensorboard_2.png" alt="TensorBoard 2" /></p>
<p>We can clearly see the improvement by increasing the learning rate. The final loss obtained with a learning rate of <code>0.00001</code> is much smaller than our original loss obtained with a learning rate of <code>0.000001</code>. In addition, we can see that the loss is decreasing more slowly at the end of training. However, the loss function still hasn't converged, as it is still decreasing significantly. Again, to fix this we could train for longer, but as before we can try increasing the learning rate even more. We can try a learning rate of <code>0.00005</code>, and we get this:</p>
<p><img src="/books/pytorch/book/ch2-linreg/assets/tensorboard_3.png" alt="TensorBoard 3" /></p>
<p>Huh? No plot!?!?? If you mouse over the <code>L</code> plot, TensorBoard will say that the value of <code>L</code> is NaN (not a number). What gives? Well, if the learning rate is too big then <code>optim.SGD</code> can explode: <code>a</code> and <code>b</code> (and consequently <code>L</code>) increase to infinity and become NaN. What &quot;too big&quot; is depends on the specific problem.</p>
<p>At this point there isn't a lot more that we can do by just tweaking the learning rate: it's either too big and causes the optimization to explode, or is too small to achieve convergence in <code>20000</code> iterations. We can certainly try more learning rates between <code>0.00001</code> and <code>0.00005</code>, but it won't be a ton better than what we already have.</p>
<a class="header" href="#using-different-optimization-algorithms" id="using-different-optimization-algorithms"><h2>Using different optimization algorithms</h2></a>
<p>So far we have been using <code>optim.SGD</code>. It is the simplest, classic way to iteratively train machine learning models. As discussed in the previous chapter, it is like moving a ball downhill, according to the current slope (aka the derivative). Generally, gradient descent is part of a class of optimization algorithms called <strong>first-order methods</strong>, since it uses only information from the first derivative of the loss function, and not higher-order derivatives. First-order methods are currently the dominant way to train most machine learning models.</p>
<p>In fact, there are many first order methods, other than simple gradient descent. Most of them are designed to offer an advantage over other first-order methods via speed to find convergence, reliability, ease of use, etc. For a fairly in-depth exploration, see <a href="http://ruder.io/optimizing-gradient-descent/index.html">this blog post</a>. To see the different optimization algorithms that are built-in to PyTorch, see <a href="https://pytorch.org/docs/stable/optim.html#algorithms">the documentation here</a>. In this list, you can see the <code>optim.Adam</code> that we used before, and the classic <code>optim.SGD</code> that we just tried.</p>
<p>We can experiment with any number of these. Here, I'll demonstrate experimenting with <code>optim.Adagrad</code>, but feel free to play around with any of them. To use <code>optim.Adagrad</code> we just need to change <code>OPTIMIZER_CONSTRUCTOR</code>, and set <code>LEARNING_RATE</code> back to <code>0.000001</code> for good measure:</p>
<pre><code class="language-python">LEARNING_RATE = 0.000001
OPTIMIZER_CONSTRUCTOR = optim.Adagrad
</code></pre>
<p>Running this we see:</p>
<p><img src="/books/pytorch/book/ch2-linreg/assets/tensorboard_4.png" alt="TensorBoard 4" /></p>
<p>Well, this is disappointing: <code>L</code> did not seem to decrease at all during training. The problem is that the learning rate used by gradient descent is really an entirely different learning rate from the Adagrad one: conceptually they are similar, but are on entirely different scales numerically. So, we just need to try different learning rates for Adagrad now. Since the value of <code>L</code> stayed constant with this very small learning rate, we expect that we need to try much larger learning rates for Adagrad. In fact, by trying learning rates of 0.5, 1, and 5, we get these plots:</p>
<p><img src="/books/pytorch/book/ch2-linreg/assets/tensorboard_5.png" alt="TensorBoard 5" /></p>
<p>Now this is looking like progress! For the first time we start to get a sense of the loss rapidly decreasing, and then slowing down substantially. In addition, the final value of <code>a</code> is now negative (which we know is correct) compared to previous runs which ended either positive or close to zero. However, by looking at the plots for <code>a</code> and <code>b</code> (and to a lesser degree <code>L</code>) we can see that we still haven't achieved convergence: <code>a</code> and <code>b</code> haven't stopped changing substantially at the end of training. So, time to increase the learning rate even more! Before doing so, I am going to delete the logs of previous runs, except for the Adagrad run with a learning rate of 5, so that we can read the plots more clearly:</p>
<pre><code class="language-bash"># This will delete logs of all the runs
rm -rf runs/
# Or, you can delete a specific run, for example:
rm -rf runs/10,\ Adagrad/
</code></pre>
<p>By trying learning rates of 10 and 50, we finally achieve convergence:</p>
<p><img src="/books/pytorch/book/ch2-linreg/assets/tensorboard_6.png" alt="TensorBoard 6" /></p>
<p>Qualitatively, this looks like convergence (with a learning rate of 10, and certainly with a learning rate of 50) since the progress that Adagrad is making on decreasing <code>L</code> (and adjusting <code>a</code> and <code>b</code>) has hit a brick wall: no matter how long we run Adagrad, we can't seem to get a loss function value lower than about \(3.9296 \cdot 10^4 \), and similarly for the values of <code>a</code> and <code>b</code>. We've finally trained our model completely.</p>
<p>Unfortunately, I don't know of an easy way to intuitively understand the differences between Adagrad, Adam, and other first-order methods. <a href="http://ruder.io/optimizing-gradient-descent/index.html">This blog post</a> does give some mathematical analysis that explains what each algorithm tries to improve upon, and some reasoning for choosing an algorithm, but it can be tricky to apply to real problems. In general, you can always start with the simplest algorithm (gradient descent), and if it isn't converging quickly enough for you, then you can switch to a more sophisticated algorithm, such as Adagrad, Adam, or others.</p>
<a class="header" href="#concluding-remarks" id="concluding-remarks"><h1>Concluding Remarks</h1></a>
<p>The experimental nature of this chapter should illustrate the practicalities of machine learning: a lot of cutting-edge machine learning currently involves running multiple experiments to try to find the best combination of hyperparameters. There isn't a golden rule for choosing the optimization algorithm and hyperparameters, but hopefully this chapter demonstrates how to alter the algorithm and hyperparameters in PyTorch and monitor convergence using TensorBoard. The most important takeaways are:</p>
<ol>
<li>Learning how to use TensorBoard</li>
<li>Recognizing convergence</li>
<li>Recognizing the symptoms of too small of a learning rate</li>
<li>Recognizing the symptoms of too large of a learning rate</li>
</ol>
<p>In future chapters I won't include the code specifically for TensorBoard (unless it is important to that chapter) since I don't want it to get in the way of actual models, but <em>I would highly encourage you to insert your own TensorBoard summary code</em>, and monitor plots of convergence in TensorBoard, since it is useful both educationally and practically.</p>
<a class="header" href="#challenge-problems" id="challenge-problems"><h1>Challenge Problems</h1></a>
<ol>
<li>Experiment on your own with a few other built-in PyTorch optimization algorithms, and try different learning rates. If you prefer a more focused goal, try to beat my configuration of an Adagrad optimizer with a learning rate of 50, and converge faster. Also note that some optimization algorithms have additional hyperparameters other than the learning rate. See the PyTorch documentation for information about these.</li>
<li>One other cause of slow convergence for the homicide rate linear regression is the somewhat extreme scaling of the problem. The \(y\) variable is a whole order of magnitude greater than the \(x\) variable, and this affects optimization. We will actually look at this problem specifically in chapter 2.4, but for now you can experiment on your own with one solution: instead of using the \(x\) and \(y\) data directly from the data set, modify them first to rescale them. A quick, hacky way is to modify the code that loads the data, so that \(x\) and \(y\) vary between 0 and 1:</li>
</ol>
<pre><code class="language-python"># Load the data, and convert to 1x30 vectors
D = pd.read_csv(&quot;homicide.csv&quot;)
# 21 and 50 are the min and max of x_data
x_data = (torch.tensor(D.age.values, dtype=torch.float) - 21.0) / (50.0 - 21.0)
# 196 and 653 are the min and max of y_data
y_data = (torch.tensor(D.num_homicide_deaths.values, dtype=torch.float) - 196.0) / (653.0 - 196.0)
</code></pre>
<p>On your own, add this code and see if you can achieve convergence using only gradient descent. You can also see how quickly you can achieve convergence using a more advanced algorithm such as Adam.</p>
<a class="header" href="#complete-code" id="complete-code"><h1>Complete Code</h1></a>
<p>The complete code including TensorBoard summaries, and using Adagrad is <a href="https://github.com/donald-pinckney/donald-pinckney.github.io/blob/src/books/pytorch/src/ch2-linreg/code/optimization/single_var_reg_optim.py">available on GitHub</a> and directly below. Note that this code lacks the plotting of the data and the linear regression line:</p>
<pre><code class="language-python">import pandas as pd
import matplotlib.pyplot as plt
import torch
import torch.optim as optim
from torch.utils.tensorboard import SummaryWriter

### Hyperparameters ###

LEARNING_RATE = 50 # Much smaller training rate, to make sure the optimization is at least reliable.
NUM_ITERS = 20000 # Twice as many training iterations, just gives us more room to experiment later.
OPTIMIZER_CONSTRUCTOR = optim.Adagrad # This is the simplest optimization algorithm.

# Load the data
D = pd.read_csv(&quot;homicide.csv&quot;)
x_dataset = torch.tensor(D.age.values, dtype=torch.float)
y_dataset = torch.tensor(D.num_homicide_deaths.values, dtype=torch.float)


### Model definition ###

# First we define the trainable parameters a and b 
a = torch.randn(1, requires_grad=True) # requires_grad means it is trainable
b = torch.randn(1, requires_grad=True)

# Then we define the prediction model
def model(x_input):
    return a * x_input + b


### Loss function definition ###

def loss(y_predicted, y_target):
    return ((y_predicted - y_target)**2).sum()


### TensorBoard Writer Setup ###
log_name = f&quot;{LEARNING_RATE}, {OPTIMIZER_CONSTRUCTOR.__name__}&quot;
writer = SummaryWriter(log_dir=f&quot;runs/{log_name}&quot;)
print(&quot;To see tensorboard, run: tensorboard --logdir=runs/&quot;)


### Training the model ###

# Setup the optimizer object, so it optimizes a and b.
optimizer = OPTIMIZER_CONSTRUCTOR([a, b], lr=LEARNING_RATE)

# Main optimization loop
for t in range(NUM_ITERS):
    # Set the gradients to 0.
    optimizer.zero_grad()
    # Compute the current predicted y's from x_dataset
    y_predicted = model(x_dataset)
    # See how far off the prediction is
    current_loss = loss(y_predicted, y_dataset)
    # Compute the gradient of the loss with respect to a and b.
    current_loss.backward()
    # Update a and b accordingly.
    optimizer.step()

    writer.add_scalar('a', a, global_step=t)
    writer.add_scalar('b', b, global_step=t)
    writer.add_scalar('L', current_loss, global_step=t)

writer.close()
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../ch2-linreg/2017-12-03-single-variable.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../ch2-linreg/2018-03-21-multi-variable.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../ch2-linreg/2017-12-03-single-variable.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../ch2-linreg/2018-03-21-multi-variable.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="/public/book_deps/js/elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="/public/book_deps/js/mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="/public/book_deps/js/searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="/public/book_deps/js/clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="/public/book_deps/js/highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="/public/book_deps/js/book.js" type="text/javascript" charset="utf-8"></script>
        <script src="/public/js/code-snippets.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
